#!/usr/bin/env python3
"""
Test pentru noul sistem IFC Background Converter
"""

import sys
import os
import time
sys.path.append('python')

from ifc_background_converter import create_background_converter, process_xdata_for_element
import json

def test_background_converter():
    print('ğŸ§ª TEST IFC BACKGROUND CONVERTER')
    print('=' * 50)
    
    # ÃncarcÄƒ datele de test
    with open('test_background_ifc_mapping.json', 'r', encoding='utf-8') as f:
        test_elements = json.load(f)
    
    print(f'ğŸ“Š Elemente de test Ã®ncÄƒrcate: {len(test_elements)}')
    
    # CreeazÄƒ converterul
    converter = create_background_converter("Test Background IFC")
    
    # AdaugÄƒ elementele Ã®n coadÄƒ
    for element in test_elements:
        # ProceseazÄƒ XDATA Ã®nainte de conversie
        processed_element = process_xdata_for_element(element)
        
        # AfiÈ™eazÄƒ diferenÈ›a dacÄƒ XDATA a fost aplicatÄƒ
        if '_opening_area_calculated' in processed_element:
            original_lateral = element.get('lateral_area', 0)
            adjusted_lateral = processed_element.get('lateral_area', 0)
            opening_area = processed_element.get('_opening_area_calculated', 0)
            print(f'ğŸ”§ XDATA procesatÄƒ pentru {element["mesh_name"]}:')
            print(f'   Original lateral_area: {original_lateral}')
            print(f'   Opening_area calculatÄƒ: {opening_area}')
            print(f'   Lateral_area ajustatÄƒ: {adjusted_lateral}')
        
        converter.queue_element_for_conversion(processed_element)
        print(f'âœ… AdÄƒugat Ã®n coadÄƒ: {element["mesh_name"]} (layer: {element["layer"]})')
    
    # PorneÈ™te conversia Ã®n background
    output_ifc = 'test_background_auto.ifc'
    print(f'\nğŸš€ Pornire conversie Ã®n background cÄƒtre: {output_ifc}')
    converter.start_background_conversion(output_ifc)
    
    print('\nâ³ AÈ™tept finalizarea conversiei...')
    start_time = time.time()
    
    # AÈ™teaptÄƒ finalizarea cu timeout
    success = converter.wait_for_completion(timeout=30.0)
    
    elapsed = time.time() - start_time
    
    if success:
        print(f'âœ… Conversia s-a finalizat cu succes Ã®n {elapsed:.2f} secunde!')
        
        # VerificÄƒ dacÄƒ fiÈ™ierul a fost creat
        if os.path.exists(output_ifc):
            file_size = os.path.getsize(output_ifc)
            print(f'ğŸ“ FiÈ™ier IFC creat: {output_ifc} ({file_size} bytes)')
            
            # VerificÄƒ conÈ›inutul cu ifcopenshell
            try:
                import ifcopenshell
                model = ifcopenshell.open(output_ifc)
                
                # NumÄƒrÄƒ elementele
                walls = model.by_type('IfcWall')
                columns = model.by_type('IfcColumn')
                spaces = model.by_type('IfcSpace')
                proxies = model.by_type('IfcProxy')
                
                print(f'\nğŸ“Š CONÈšINUT IFC GENERAT:')
                print(f'   IfcWall: {len(walls)}')
                print(f'   IfcColumn: {len(columns)}')
                print(f'   IfcSpace: {len(spaces)}')
                print(f'   IfcProxy: {len(proxies)}')
                
                # VerificÄƒ XDATA pentru IfcSpace
                for space in spaces:
                    space_name = space.Name
                    print(f'\nğŸ  {space_name}:')
                    
                    for rel in space.IsDefinedBy:
                        if hasattr(rel, 'RelatingPropertyDefinition'):
                            pset = rel.RelatingPropertyDefinition
                            if hasattr(pset, 'Name') and pset.Name == 'AutoGeneratedProperties':
                                for prop in pset.HasProperties:
                                    if prop.Name == 'LateralArea':
                                        lateral_area = prop.NominalValue.wrappedValue
                                        print(f'   ğŸ“Š Lateral Area: {lateral_area} mÂ²')
                                        
                                        # Pentru spaÈ›iul cu XDATA
                                        if space_name == 'Space_LivingRoom_1':
                                            expected = 54.0 - (1.2*2.1 + 0.8*2.0)  # 54.0 - 4.12 = 49.88
                                            print(f'   ğŸ”§ XDATA aplicatÄƒ: 54.0 - {1.2*2.1 + 0.8*2.0} = {expected:.2f}')
                                            if abs(lateral_area - expected) < 0.1:
                                                print(f'   âœ… XDATA corect aplicatÄƒ!')
                                            else:
                                                print(f'   âŒ XDATA incorect: {lateral_area} != {expected:.2f}')
                                    elif prop.Name == 'OpeningAreaDeducted':
                                        opening_area = prop.NominalValue.wrappedValue
                                        print(f'   ğŸ”§ Opening Area dedusÄƒ: {opening_area} mÂ²')
                
                print(f'\nğŸ‰ TESTUL IFC BACKGROUND CONVERTER A FOST FINALIZAT CU SUCCES!')
                
            except ImportError:
                print('âš ï¸ ifcopenshell nu este disponibil pentru verificarea conÈ›inutului')
            except Exception as e:
                print(f'âŒ Eroare la verificarea IFC: {e}')
                
        else:
            print(f'âŒ FiÈ™ierul IFC nu a fost creat: {output_ifc}')
    else:
        print(f'âŒ Conversia a eÈ™uat sau a depÄƒÈ™it timeout-ul de 30 secunde')
    
    return success

if __name__ == '__main__':
    test_background_converter()